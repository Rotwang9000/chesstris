<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Chesstris Renderer Test</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden;
			background-color: #121212;
			color: #ffffff;
			font-family: Arial, sans-serif;
		}
		
		#game-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}
		
		#info-panel {
			position: absolute;
			top: 10px;
			left: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			z-index: 100;
			max-width: 300px;
		}
		
		#debug-panel {
			position: absolute;
			top: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 5px;
			z-index: 100;
			max-width: 300px;
		}
		
		button {
			background-color: #2196F3;
			color: white;
			border: none;
			padding: 8px 16px;
			margin: 5px;
			border-radius: 4px;
			cursor: pointer;
		}
		
		button:hover {
			background-color: #0b7dda;
		}
	</style>
	
	<!-- Import THREE.js - use CDN in global mode for better compatibility -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	
	<!-- Import OrbitControls globally -->
	<script>
		// Make OrbitControls available globally
		// This is modified code from THREE.js OrbitControls.js to work with the global THREE object
		(function() {
			// OrbitControls implementation
			// Copyright © 2010-2022 three.js authors
			const _changeEvent = { type: 'change' };
			const _startEvent = { type: 'start' };
			const _endEvent = { type: 'end' };
			
			class OrbitControls extends THREE.EventDispatcher {
				constructor(object, domElement) {
					super();
					
					this.object = object;
					this.domElement = domElement;
					
					// Default settings
					this.enabled = true;
					this.target = new THREE.Vector3();
					this.dampingFactor = 0.05;
					this.enableDamping = false;
					
					// Internals
					this._state = 0;
					this._target = new THREE.Vector3();
					this._lastPosition = new THREE.Vector3();
					this._lastQuaternion = new THREE.Quaternion();
					
					// Basic implementation
					this.update = function() {
						if (!this.enabled) return;
						
						// If damping is enabled, smoothly transition
						if (this.enableDamping) {
							this.object.position.lerp(this._target, this.dampingFactor);
						}
						
						return true;
					};
					
					// Basic event listeners
					this.domElement.addEventListener('contextmenu', this._onContextMenu);
					this.domElement.addEventListener('pointerdown', this._onPointerDown);
					this.domElement.addEventListener('wheel', this._onMouseWheel);
					
					this._onPointerDown = function() {};
					this._onMouseWheel = function() {};
					this._onContextMenu = function(event) { event.preventDefault(); };
				}
				
				dispose() {
					this.domElement.removeEventListener('contextmenu', this._onContextMenu);
					this.domElement.removeEventListener('pointerdown', this._onPointerDown);
					this.domElement.removeEventListener('wheel', this._onMouseWheel);
				}
			}
			
			// Make available globally
			window.OrbitControls = OrbitControls;
		})();
	</script>
</head>
<body>
	<div id="game-container"></div>
	<div id="info-panel">
		<h2>Chesstris Game Test</h2>
		<p>Testing the full game renderer with improved visuals</p>
		<p>You should now see:</p>
		<ul>
			<li>A proper 8×2 home zone (orange cells) with complete chess setup</li>
			<li>A blue path from home zone to center</li>
			<li>A falling tetromino piece (green T-shape)</li>
			<li>Wireframe outlines and labels on all elements</li>
		</ul>
		<p>Use mouse to rotate, scroll to zoom, and right-click to pan</p>
		<p>Or use the debug buttons in the top-right corner</p>
	</div>
	
	<div id="debug-panel">
		<h3>Debug Controls</h3>
		<button id="btn-reset-camera">Reset Camera</button>
		<button id="btn-top-view">Top View</button>
		<button id="btn-side-view">Side View</button>
		<div id="camera-info"></div>
	</div>
	
	<!-- Debug script to show what's going on -->
	<script>
		// Log uncaught errors to help with debugging
		window.addEventListener('error', function(event) {
			console.error('Uncaught error:', event.error);
			
			// Update the info panel to show error
			const infoPanel = document.getElementById('info-panel');
			if (infoPanel) {
				infoPanel.innerHTML += `<div style="color: red; margin-top: 20px;">
					<strong>Error detected:</strong><br>
					${event.message}<br>
					<small>Check console for details</small>
				</div>`;
			}
		});
		
		// Add a direct fallback in case module loading fails
		window.addEventListener('load', function() {
			// Give modules a chance to load first
			setTimeout(function() {
				// If no scene exists after 3 seconds, create a minimal scene
				if (!window.scene) {
					console.warn('No scene detected after 3 seconds, creating fallback scene');
					const infoPanel = document.getElementById('info-panel');
					if (infoPanel) {
						infoPanel.innerHTML += `<div style="color: orange; margin-top: 20px;">
							<strong>Using fallback renderer</strong><br>
							Module system may have failed to load
						</div>`;
					}
					
					// Create a minimal direct THREE.js scene
					const container = document.getElementById('game-container');
					if (container && window.THREE) {
						// Create scene, camera, renderer
						const scene = new THREE.Scene();
						scene.background = new THREE.Color(0x121212);
						
						// Store scene globally for debuging
						window.scene = scene;
						
						// Create camera
						const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
						camera.position.set(12, 15, 20);
						camera.lookAt(12, 0, 12);
						window.camera = camera;
						
						// Create renderer
						const renderer = new THREE.WebGLRenderer({ antialias: true });
						renderer.setSize(window.innerWidth, window.innerHeight);
						renderer.setPixelRatio(window.devicePixelRatio);
						container.appendChild(renderer.domElement);
						
						// Create controls if available
						let controls;
						if (window.OrbitControls) {
							controls = new OrbitControls(camera, renderer.domElement);
							controls.enableDamping = true;
							controls.dampingFactor = 0.05;
						}
						
						// Create board
						const boardGroup = new THREE.Group();
						scene.add(boardGroup);
						
						// Create pieces
						const piecesGroup = new THREE.Group();
						scene.add(piecesGroup);
						
						// Add a grid for reference
						const gridHelper = new THREE.GridHelper(40, 40, 0xff0000, 0xffffff);
						scene.add(gridHelper);
						
						// Define home zone properties
						const homeZoneSize = { width: 8, depth: 2 };
						const homeZoneStartX = 8;
						const homeZoneStartZ = 15;
						
						// Create home zone cells
						for (let z = 0; z < homeZoneSize.depth; z++) {
							for (let x = 0; x < homeZoneSize.width; x++) {
								// Create cell with home zone material
								const cellGeometry = new THREE.BoxGeometry(1, 0.2, 1);
								const cellMaterial = new THREE.MeshPhongMaterial({
									color: 0xFFA500, // Orange for home zone
									specular: 0xFFFFFF,
									shininess: 30
								});
								
								const cell = new THREE.Mesh(cellGeometry, cellMaterial);
								cell.position.set(homeZoneStartX + x, 0, homeZoneStartZ + z);
								boardGroup.add(cell);
								
								// Add wireframe
								const edgesGeometry = new THREE.EdgesGeometry(cellGeometry);
								const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
								const wireframe = new THREE.LineSegments(edgesGeometry, edgesMaterial);
								cell.add(wireframe);
							}
						}
						
						// Create path from home zone to center
						for (let z = 10; z < homeZoneStartZ; z++) {
							for (let x = 10; x < 15; x++) {
								if ((x + z) % 2 === 0) { // Checkerboard pattern
									// Create regular cells
									const cellGeometry = new THREE.BoxGeometry(1, 0.2, 1);
									const cellMaterial = new THREE.MeshPhongMaterial({
										color: 0x42A5F5, // Blue for regular cells
										specular: 0xFFFFFF,
										shininess: 30
									});
									
									const cell = new THREE.Mesh(cellGeometry, cellMaterial);
									cell.position.set(x, 0, z);
									boardGroup.add(cell);
									
									// Add wireframe
									const edgesGeometry = new THREE.EdgesGeometry(cellGeometry);
									const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
									const wireframe = new THREE.LineSegments(edgesGeometry, edgesMaterial);
									cell.add(wireframe);
								}
							}
						}
						
						// Create chess pieces - back row (standard chess setup)
						const backRowPieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
						for (let i = 0; i < backRowPieces.length; i++) {
							// Create piece based on type
							let pieceGeometry;
							let height = 1.0;
							const type = backRowPieces[i];
							
							switch (type) {
								case 'pawn':
									pieceGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8, 8);
									height = 0.8;
									break;
								case 'rook':
									pieceGeometry = new THREE.BoxGeometry(0.4, 1.0, 0.4);
									height = 1.0;
									break;
								case 'knight':
									pieceGeometry = new THREE.SphereGeometry(0.3, 8, 8);
									height = 0.9;
									break;
								case 'bishop':
									pieceGeometry = new THREE.ConeGeometry(0.3, 1.1, 8);
									height = 1.1;
									break;
								case 'queen':
									pieceGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.3, 8);
									height = 1.3;
									break;
								case 'king':
									pieceGeometry = new THREE.CylinderGeometry(0.35, 0.45, 1.5, 8);
									height = 1.5;
									break;
							}
							
							// Create material
							const pieceMaterial = new THREE.MeshPhongMaterial({
								color: 0xFF00FF, // Magenta color for pieces
								specular: 0xFFFFFF,
								shininess: 100
							});
							
							// Create mesh
							const piece = new THREE.Mesh(pieceGeometry, pieceMaterial);
							piece.position.set(homeZoneStartX + i, height/2, homeZoneStartZ + 1);
							piecesGroup.add(piece);
							
							// Add wireframe
							const edgesGeometry = new THREE.EdgesGeometry(pieceGeometry);
							const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
							const wireframe = new THREE.LineSegments(edgesGeometry, edgesMaterial);
							piece.add(wireframe);
							
							// Add label
							const canvas = document.createElement('canvas');
							canvas.width = 64;
							canvas.height = 32;
							const ctx = canvas.getContext('2d');
							
							// Background
							ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
							ctx.fillRect(0, 0, canvas.width, canvas.height);
							
							// Text
							ctx.fillStyle = 'white';
							ctx.font = 'bold 12px Arial';
							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';
							ctx.fillText(type.toUpperCase(), canvas.width/2, canvas.height/2);
							
							// Create sprite
							const texture = new THREE.CanvasTexture(canvas);
							const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
							const sprite = new THREE.Sprite(spriteMaterial);
							sprite.position.set(0, height + 0.3, 0);
							sprite.scale.set(0.5, 0.25, 1);
							piece.add(sprite);
						}
						
						// Create pawns (front row)
						for (let i = 0; i < homeZoneSize.width; i++) {
							const pieceGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8, 8);
							const pieceMaterial = new THREE.MeshPhongMaterial({
								color: 0xFF00FF,
								specular: 0xFFFFFF,
								shininess: 100
							});
							
							const pawn = new THREE.Mesh(pieceGeometry, pieceMaterial);
							pawn.position.set(homeZoneStartX + i, 0.4, homeZoneStartZ);
							piecesGroup.add(pawn);
							
							// Add wireframe
							const edgesGeometry = new THREE.EdgesGeometry(pieceGeometry);
							const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
							const wireframe = new THREE.LineSegments(edgesGeometry, edgesMaterial);
							pawn.add(wireframe);
							
							// Add label
							const canvas = document.createElement('canvas');
							canvas.width = 64;
							canvas.height = 32;
							const ctx = canvas.getContext('2d');
							
							// Background
							ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
							ctx.fillRect(0, 0, canvas.width, canvas.height);
							
							// Text
							ctx.fillStyle = 'white';
							ctx.font = 'bold 12px Arial';
							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';
							ctx.fillText('PAWN', canvas.width/2, canvas.height/2);
							
							// Create sprite
							const texture = new THREE.CanvasTexture(canvas);
							const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
							const sprite = new THREE.Sprite(spriteMaterial);
							sprite.position.set(0, 1.0, 0);
							sprite.scale.set(0.5, 0.25, 1);
							pawn.add(sprite);
						}
						
						// Create a falling tetromino (T shape)
						const tetrominoGroup = new THREE.Group();
						scene.add(tetrominoGroup);
						
						function createTetromino() {
							// Clear previous tetromino
							while (tetrominoGroup.children.length > 0) {
								tetrominoGroup.remove(tetrominoGroup.children[0]);
							}
							
							// T shape (center and 3 blocks)
							const positions = [
								{ x: 0, z: 0 },  // center
								{ x: -1, z: 0 }, // left
								{ x: 1, z: 0 },  // right
								{ x: 0, z: 1 }   // bottom
							];
							
							// Create blocks
							positions.forEach(pos => {
								const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
								const blockMaterial = new THREE.MeshPhongMaterial({
									color: 0x00FF00,  // Green tetromino
									transparent: true,
									opacity: 0.8,
									specular: 0xFFFFFF,
									shininess: 30
								});
								
								const block = new THREE.Mesh(blockGeometry, blockMaterial);
								block.position.set(pos.x, 0, pos.z);
								
								// Add wireframe
								const edgesGeometry = new THREE.EdgesGeometry(blockGeometry);
								const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
								const wireframe = new THREE.LineSegments(edgesGeometry, edgesMaterial);
								block.add(wireframe);
								
								tetrominoGroup.add(block);
							});
							
							// Position the tetromino at the top
							tetrominoGroup.position.set(12, tetrominoHeight, 5);
						}
						
						// Tetromino animation variables
						let tetrominoHeight = 5;
						let fallSpeed = 0.03;
						
						createTetromino();
						
						// Add ambient light
						const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
						scene.add(ambientLight);
						
						// Add directional light
						const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
						directionalLight.position.set(10, 20, 10);
						scene.add(directionalLight);
						
						// Add a point light for highlights
						const pointLight = new THREE.PointLight(0xffffff, 0.8, 50);
						pointLight.position.set(0, 20, 0);
						scene.add(pointLight);
						
						// Attempt to create a simple skybox
						try {
							const skyGeometry = new THREE.SphereGeometry(200, 32, 16);
							const skyMaterial = new THREE.MeshBasicMaterial({
								color: 0x87CEEB, // Sky blue
								side: THREE.BackSide
							});
							const sky = new THREE.Mesh(skyGeometry, skyMaterial);
							scene.add(sky);
						} catch (error) {
							console.warn('Could not create skybox:', error);
						}
						
						// Add fog
						scene.fog = new THREE.FogExp2(0x87CEEB, 0.001);
						
						// Camera controls for the fallback
						window.resetCamera = () => {
							camera.position.set(12, 15, 20);
							camera.lookAt(12, 0, 12);
						};
						
						window.topView = () => {
							camera.position.set(12, 30, 12);
							camera.lookAt(12, 0, 12);
						};
						
						window.sideView = () => {
							camera.position.set(30, 5, 12);
							camera.lookAt(12, 0, 12);
						};
						
						// Animation function
						function animate() {
							requestAnimationFrame(animate);
							
							// Update controls if available
							if (controls) {
								controls.update();
							}
							
							// Rotate pieces slightly
							piecesGroup.children.forEach(piece => {
								piece.rotation.y += 0.01;
							});
							
							// Animate falling tetromino
							tetrominoHeight -= fallSpeed;
							tetrominoGroup.position.y = tetrominoHeight;
							
							// Reset tetromino when it falls below the board
							if (tetrominoHeight < -2) {
								tetrominoHeight = 5;
								// Randomize x position a bit
								tetrominoGroup.position.x = 8 + Math.floor(Math.random() * 8);
							}
							
							// Render scene
							renderer.render(scene, camera);
						}
						
						// Start animation
						animate();
						
						// Handle window resize
						window.addEventListener('resize', () => {
							camera.aspect = window.innerWidth / window.innerHeight;
							camera.updateProjectionMatrix();
							renderer.setSize(window.innerWidth, window.innerHeight);
						});
						
						console.log('Fallback renderer created successfully');
					} else {
						console.error('Cannot create fallback: missing container or THREE.js');
					}
				}
			}, 3000); // Wait 3 seconds before checking
		});
	</script>
	
	<!-- Import renderer test module -->
	<script type="module">
		// Direct import path for modules
		import { init, initCameraControls } from './js/rendering/test.js';
		
		document.addEventListener('DOMContentLoaded', () => {
			try {
				console.log('Initializing test renderer directly...');
				// Initialize the test renderer
				init();
				
				// Initialize camera controls
				initCameraControls();
				
				// Update camera info
				function updateCameraInfo() {
					const cameraInfo = document.getElementById('camera-info');
					if (cameraInfo && window.camera) {
						const pos = window.camera.position;
						cameraInfo.textContent = `Camera: x=${pos.x.toFixed(1)}, y=${pos.y.toFixed(1)}, z=${pos.z.toFixed(1)}`;
					}
					requestAnimationFrame(updateCameraInfo);
				}
				
				// Start updating camera info
				updateCameraInfo();
				
				// Set up camera controls
				document.getElementById('btn-reset-camera').addEventListener('click', () => {
					if (window.resetCamera) window.resetCamera();
				});
				
				document.getElementById('btn-top-view').addEventListener('click', () => {
					if (window.topView) window.topView();
				});
				
				document.getElementById('btn-side-view').addEventListener('click', () => {
					if (window.sideView) window.sideView();
				});
			} catch (error) {
				console.error('Error in module initialization:', error);
				document.getElementById('info-panel').innerHTML += `
					<div style="color: red; margin-top: 20px;">
						<strong>Module Error:</strong><br>
						${error.message}<br>
					</div>
				`;
			}
		});
	</script>
</body>
</html> 